[
["index.html", "A gentle Introduction of Coding with R Preface", " A gentle Introduction of Coding with R Masumbuko Semba 2018-11-16 Preface We live in an age where data generated and collected in a fraction of a minute is enormous. To get insight out of these data they must analysed. Several tools have been developed to tacke the issue of data and obtain knowledge out of this digital data age. One of the tools is the R programming language, which has increased recently and become a one-stop solution to data problem. In this book, I introduce to the readers some of the useful packages and tools in R that are commonly used to handle and tranform data and produce elegant graphics with R programming language. The book talks about coding using R programming languages. Coding is nothing more than telling a computer what to do in a language the computer understands. Learning to code will help you to develop critical thinking skills and ability to solve problems. We will cover various analytical processes and methods that will help reader to apply them to analyse their own datasets. "],
["prerequisities.html", "Prerequisities", " Prerequisities I developed this book with a focus to readers who are unfamiliar with statistical analysis and coding. I tried to make it as simple as posssible to provide the background of underlaying statistics to provide a glimpse of the theory behind statistical concepts. Because the book use R, I will take through each step in R so that the reader get familiar with this powerful programming language. — Masumbuko Semba "],
["resources.html", "Resources", " Resources Here is a list of resources that make you up and running in R. I will keep adding the list whenever I find a resourceful document floating online. A Sufficient Introduction to R UC Business Analytics R Programming Guide graphics with ggplot2 ggplot graphics Beautiful plotting in R with ggplot2 The definitive guide of Rmarkdown bookdownplus "],
["introduction-to-r-rstudio.html", "Chapter 1 Introduction to R, Rstudio 1.1 What is R? 1.2 What is RStudio?", " Chapter 1 Introduction to R, Rstudio 1.1 What is R? R is a language for data manipulation and graphics (R Core Team 2018). Xia, Sun, and Chen (2018) pointed out that R is a vehicle for newly developing methods of interactive data analysis. R have rapidly developed and extended its capability to a large collection of packages provided by researchers and volunteers. R can be downloaded from https://www.r-project.org and available for all thre major operating systems—Windows, Mac and Unix/Linux. Like other statistical software, R provides a statistical framework and terminal-based interface for users to parse commands for data ingestion, manipulation and graphics. The R programming usage has become one-stop solution to data analysis. R was created in 1993 and has evolved into a stable programming language. It has become a de facto standard for data analysis both in academic and industry sectors. R has its roots in the statistics community, being created by statistians for statistics. Many of its core tools are directed toward statistics. Being an open-source language, R has many advantage oover other commercial statistical platform like MATLAB, SAS and SPSS. The big rip for using R is its ecosystem of packages. 1.1.1 Installing R R is available on most computing platform like Windows. Linux and Mac. There are two ways of installing R in the computer. The first is downloading latest version of R Binary and compiling R from the https://cran.r-project.org/ depending on your operating system. The compiled binary executes and install R in your machine. R can also be installed using packages managers. For example, Ubuntu users can install R using the apt-get package manager by running: &gt; sudo apt-get install r-base r-base-dev Similarly, Mac users can install R using ports &gt; sudo port install R There is an active community of R developers which regularly releases a new version R. Each version has a name assigned to it. Except for major resease, the version of R are usually backward compatible in terms of their funcitonality. The version and common packages used in this book can be accessed by simply passing a commands devtools::session_info() in the console devtools::session_info(pkgs = NULL) - Session info ---------------------------------------------------------- setting value version R version 3.4.4 (2018-03-15) os Windows &gt;= 8 x64 system x86_64, mingw32 ui RStudio language (EN) collate English_United States.1252 ctype English_United States.1252 tz Africa/Nairobi date 2018-11-16 - Packages -------------------------------------------------------------- package * version date lib source assertthat 0.2.0 2017-04-11 [1] CRAN (R 3.4.3) backports 1.1.2 2017-12-13 [1] CRAN (R 3.4.3) base64enc 0.1-3 2015-07-28 [1] CRAN (R 3.4.1) bindr 0.1.1 2018-03-13 [1] CRAN (R 3.4.4) bindrcpp * 0.2.2 2018-03-29 [1] CRAN (R 3.4.4) bookdown 0.7 2018-02-18 [1] CRAN (R 3.4.4) callr 3.0.0 2018-08-24 [1] CRAN (R 3.4.4) cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.4.3) cli 1.0.1 2018-09-25 [1] CRAN (R 3.4.4) colorspace 1.3-2 2016-12-14 [1] CRAN (R 3.4.3) crayon 1.3.4 2017-09-16 [1] CRAN (R 3.4.3) crosstalk 1.0.0 2016-12-21 [1] CRAN (R 3.4.3) debugme 1.1.0 2017-10-22 [1] CRAN (R 3.4.3) desc 1.2.0 2018-05-01 [1] CRAN (R 3.4.4) devtools 2.0.1 2018-10-26 [1] CRAN (R 3.4.4) digest 0.6.18 2018-10-10 [1] CRAN (R 3.4.4) dplyr * 0.7.7 2018-10-16 [1] CRAN (R 3.4.4) DT 0.4 2018-01-30 [1] CRAN (R 3.4.4) evaluate 0.11 2018-07-17 [1] CRAN (R 3.4.4) fansi 0.4.0 2018-10-05 [1] CRAN (R 3.4.4) forcats 0.3.0 2018-02-19 [1] CRAN (R 3.4.3) fs 1.2.6 2018-08-23 [1] CRAN (R 3.4.4) ggplot2 * 3.1.0 2018-10-25 [1] CRAN (R 3.4.4) glue 1.3.0 2018-07-17 [1] CRAN (R 3.4.4) gtable 0.2.0 2016-02-26 [1] CRAN (R 3.4.3) haven * 1.1.2 2018-06-27 [1] CRAN (R 3.4.4) highr 0.7 2018-06-09 [1] CRAN (R 3.4.4) hms 0.4.2 2018-03-10 [1] CRAN (R 3.4.4) htmltools 0.3.6 2017-04-28 [1] CRAN (R 3.4.3) htmlwidgets 1.2 2018-04-19 [1] CRAN (R 3.4.4) httpuv 1.4.5 2018-07-19 [1] CRAN (R 3.4.4) httr 1.3.1 2017-08-20 [1] CRAN (R 3.4.3) jsonlite 1.5 2017-06-01 [1] CRAN (R 3.4.3) kableExtra * 0.9.0 2018-05-21 [1] CRAN (R 3.4.4) knitr 1.20 2018-02-20 [1] CRAN (R 3.4.3) labeling 0.3 2014-08-23 [1] CRAN (R 3.4.1) later 0.7.5 2018-09-18 [1] CRAN (R 3.4.4) lazyeval 0.2.1 2017-10-29 [1] CRAN (R 3.4.3) lubridate * 1.7.4 2018-04-11 [1] CRAN (R 3.4.4) magrittr 1.5 2014-11-22 [1] CRAN (R 3.4.3) memoise 1.1.0 2017-04-21 [1] CRAN (R 3.4.3) mime 0.6 2018-10-05 [1] CRAN (R 3.4.4) munsell 0.5.0 2018-06-12 [1] CRAN (R 3.4.4) pillar 1.3.0 2018-07-14 [1] CRAN (R 3.4.4) pkgbuild 1.0.2 2018-10-16 [1] CRAN (R 3.4.4) pkgconfig 2.0.2 2018-08-16 [1] CRAN (R 3.4.4) pkgload 1.0.2 2018-10-29 [1] CRAN (R 3.4.4) plyr 1.8.4 2016-06-08 [1] CRAN (R 3.4.3) prettyunits 1.0.2 2015-07-13 [1] CRAN (R 3.4.4) processx 3.2.0 2018-08-16 [1] CRAN (R 3.4.4) promises 1.0.1 2018-04-13 [1] CRAN (R 3.4.4) ps 1.1.0 2018-08-10 [1] CRAN (R 3.4.4) purrr 0.2.5 2018-05-29 [1] CRAN (R 3.4.4) R6 2.3.0 2018-10-04 [1] CRAN (R 3.4.4) Rcpp 1.0.0 2018-11-07 [1] CRAN (R 3.4.4) readr * 1.1.1 2017-05-16 [1] CRAN (R 3.4.3) readxl * 1.1.0 2018-04-20 [1] CRAN (R 3.4.4) remotes 2.0.2 2018-10-30 [1] CRAN (R 3.4.4) rlang 0.3.0.1 2018-10-25 [1] CRAN (R 3.4.4) rmarkdown 1.10 2018-06-11 [1] CRAN (R 3.4.4) rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.4.3) rstudioapi 0.7 2017-09-07 [1] CRAN (R 3.4.3) rvest 0.3.2 2016-06-17 [1] CRAN (R 3.4.3) scales 1.0.0 2018-08-09 [1] CRAN (R 3.4.4) servr 0.10 2018-05-30 [1] CRAN (R 3.4.4) sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.4.4) shiny 1.1.0 2018-05-17 [1] CRAN (R 3.4.4) stringi 1.1.7 2018-03-12 [1] CRAN (R 3.4.4) stringr 1.3.1 2018-05-10 [1] CRAN (R 3.4.4) testthat 2.0.0 2017-12-13 [1] CRAN (R 3.4.3) tibble 1.4.2 2018-01-22 [1] CRAN (R 3.4.3) tidyr * 0.8.1 2018-05-18 [1] CRAN (R 3.4.4) tidyselect 0.2.5 2018-10-11 [1] CRAN (R 3.4.4) usethis 1.4.0 2018-08-14 [1] CRAN (R 3.4.4) utf8 1.1.4 2018-05-24 [1] CRAN (R 3.4.4) viridisLite 0.3.0 2018-02-01 [1] CRAN (R 3.4.3) withr 2.1.2 2018-03-15 [1] CRAN (R 3.4.4) xfun 0.3 2018-07-06 [1] CRAN (R 3.4.4) xml2 1.2.0 2018-01-24 [1] CRAN (R 3.4.3) xtable 1.8-3 2018-08-29 [1] CRAN (R 3.4.4) yaml 2.2.0 2018-07-25 [1] CRAN (R 3.4.4) [1] C:/Users/Semba/Documents/R/win-library/3.4 [2] C:/Program Files/R/R-3.4.4/library 1.2 What is RStudio? RStudio is a free and open-source integrated development environment (IDE) for R (RStudio Team 2016). Rstudio is free available from https://www.rstudio.com/products/rstudio/downloads3/ and work in the four operating systems—Windows, Mac, Ubuntu and Fedora. To obtain the reference infomation for citing RStudio in publication by simply typing RStudio.version() command in the console. 1.2.1 Basic Featurs of RStudio RStudio allows the user to run R in a more user-friendly environment (Xia, Sun, and Chen 2018). The Graphic User Interface (GUI) of RStudio usually consist of four main panels (Figure 1.1); source editor and data viewer: Is an editor for editing files and writing scripts and markdown documents. It also used to view data frame similar to Excel spreadsheet. Source editor is recommended in most programming work because of its efficient way to manage scripts and Rmarkdown document for reproducible work. environment (workspace browser) and history:the environment and history tabs includes all the active objects and history of all commands executed in the session. R consoles: is similar to console in base R and environment where we can execute commands and see the outputs. Programmers discourage the use of console because of inefficient and inability for reproducible works. files, plots, packages, help, and viewer: This panel contains tabs essentially for viewing outputs (plots and viewer) and search for help and packages Figure 1.1: The RStudio basic features References "],
["r-rrogramming-language-with-rstudio.html", "Chapter 2 R Rrogramming Language with Rstudio 2.1 Operators 2.2 Setting Working Directory 2.3 Loading packages 2.4 Understanding Data in R 2.5 Exercise 2.6 Data Frame 2.7 Exercise", " Chapter 2 R Rrogramming Language with Rstudio In this section, I switfly introduce the syntax of R language. R is an interpreted language—the expression specified in this languages executes line by line similar to other languages like python or ruby rather than compiling the source code an executable chunk as in C++. One of the power of R language is its dynamic—infers the data types of the variables based on the context. We do not need to declare variables separately. R is considered as esoteric because its syntax are easily understood by people from different fields. 2.1 Operators R provides arithmetric operators for addition (+) , substraction (-), multiplication (*), division (/), and exponential (^). 2.1.1 Arithmetric Because of the convinient, we will use Rstudio. In console just write an expression 2 + 3 and click enter. Unlike other programming languages, coding in R does not need to terminate the expression or lines with a semicolon. As we expected, R returns the answer as 5 2+3 ## [1] 5 We often use an assignment operator to assing the value of an expression to a variable. R has two assignment operators—the conventional assignment operator =, which is present in most programming languages, and the arrows &lt;- and -&gt; which are specific to R. The expression x = 5 assign the value 5 to x, likewise the expression x &lt;- 5 and 5 -&gt; x have the same effect. Throughout this book, we stick on the conventional assignment operator (=) We can create expression using variables. for instance, we assign the value 5 to the variable x and evaluate the square of x using the exponential ^ operator. x = 5 x^2 ## [1] 25 R has peculiar syntax when it comes to variable names. The dot character . has a completely different meaning as compared to other programming languages. In R, we can use . in the variable names, so x.1 and x_1 are perfectly valid. In practice, the dot operator is used as a visual separator in variable names, similar to underscore in most other programming languages. 2.1.2 Functions Functions in R are first class objects, which means that they can be treated much like any other R object. Importantly, Functions can be passed as arguments to other functions Functions can be nested, so that you can define a function inside of another function The return value of a function is the last expression in the function body to be evaluated. R functions arguments can be matched positionally or by name. So the following calls to sd are all equivalent data = rnorm(25) sum(data) ## [1] 2.673231 sd(data) ## [1] 1.187606 mean(data) ## [1] 0.1069293 median(data) ## [1] -0.01281311 2.2 Setting Working Directory Xia, Sun, and Chen (2018) defined a working directory as a folder in your computer or server where you stores the raw data, codes and output for that specific project. This folder is important in programming because it allows to read the data and write outputs to this working directory. In R you can set working directory with setwd() function and check whether you are in the right working directory with the getwd() function. # getwd() setwd(&quot;E:/Data Manipulation/R_dege/&quot;) 2.3 Loading packages R is made up of many user-written package. The base version of R allows user to get started in R, but the capabilities of base R are limited and additional packages are required for smooth performance of working with data. Packages are collections of R functions, data, and compiled code in a well-defined format. The directory where packages are stored is called the library. R comes with a standard set of packages. Others are available for download and installation. Once installed, they have to be loaded into the session to be used. require(dplyr) require(readr) require(lubridate) require(readxl) require(haven) require(ggplot2) require(kableExtra) 2.4 Understanding Data in R 2.4.1 Data Types There are some basic data types that are commonly used Integers: These are integer numbers int.1 = 1:9 int.2 = seq(23, 1500, 68) You can check if the data is integer with is.integer() and can convert numeric value to an integer with as.integer() function. Numeric: These could be any number (whole or decimal number). You can check if the data is integer with is.integer() num = seq(2.5, 45, 3.8) Strings: These collection of characters. This often are text data like names. You can check if the data is integer with is.character() kata = c(&quot;Dege&quot;, &quot;Mchikichini&quot;, &quot;Mwembe Mdogo&quot;, &quot;Cheka&quot;) class(kata) ## [1] &quot;character&quot; Factor: These are strings from finite set of values. For example, we might wish to store a variable that records gender of people. You can check if the data is factor with is.factor() and use as.factor() to convert string to factor sex = c(&quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;) sex = as.factor(sex) class(sex) ## [1] &quot;factor&quot; levels(sex) ## [1] &quot;Female&quot; &quot;Male&quot; Often times we need to know the possible groups that are in the factor data. This can be achieved with the levels() function levels(sex) ## [1] &quot;Female&quot; &quot;Male&quot; levels(kata) ## NULL Often we wish to take a continuous numerical vector and transform it into a factor. The function cut() takes a vector of numerical data and creates a factor based on your give cut-points. Let us make a fictional income of 508 people with rnorm() function. income = rnorm(n = 508, mean = 500, sd = 80) hist(income, col = &quot;green&quot;, main = &quot;&quot;, las = 1, xlab = &quot;Individual Income&quot;) Figure 2.1: Income distribution #mosaic::plotDist(dist = &quot;norm&quot;, mean = 500, sd = 80) We can now breaks the distribution into groups and make a simple plot as shown in figure 2.2, where those with income less than 400 were about 50, followed with a group with income range between 400 and 500 of about 200 and 250 people receive income above 500 group = cut(income, breaks = c(300,400,500,800), labels = c(&quot;Below 400&quot;, &quot;400-500&quot;, &quot;Above 500&quot;)) is.factor(group) ## [1] TRUE levels(group) ## [1] &quot;Below 400&quot; &quot;400-500&quot; &quot;Above 500&quot; barplot(table(group), las = 1, horiz = FALSE, col = c(&quot;blue&quot;, &quot;red&quot;, &quot;blue&quot;), ylab = &quot;Frequency&quot;, xlab = &quot;Group of Income&quot;) Figure 2.2: Barplot of grouped income data = data.frame(group, income) Logicals: This is a special case of a factor that can only take on the values TRUE and FALSE. R is case-sensitive, therefore you must always capitalize TRUE and FALSE in function in R. 2.5 Exercise Create a vector of character strings with six elements test &lt;- c(&#39;red&#39;,&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;,&#39;blue&#39;,&#39;green&#39;) and then Transform the test vector just you created into a factor. Use the levels() command to determine the levels (and order) of the factor you just created. Transform the factor you just created into integers. Comment on the relationship between the integers and the order of the levels you found in part (b). Use some sort of comparison to create a vector that identifies which factor elements are the red group. Suppose we vectors that give a students name, their GPA, and their major. We want to come up with a list of forestry students with a GPA of greater than 3.0. Name &lt;- c(&#39;Adam&#39;,&#39;Benjamin&#39;,&#39;Caleb&#39;,&#39;Daniel&#39;,&#39;Ephriam&#39;, &#39;Frank&#39;,&#39;Gideon&#39;) GPA &lt;- c(3.2, 3.8, 2.6, 2.3, 3.4, 3.7, 4.0) Major &lt;- c(&#39;Math&#39;,&#39;Forestry&#39;,&#39;Biology&#39;,&#39;Forestry&#39;,&#39;Forestry&#39;,&#39;Math&#39;,&#39;Forestry&#39;) Create a vector of TRUE/FALSE values that indicate whether the students GPA is greater than 3.0. Create a vector of TRUE/FALSE values that indicate whether the students’ major is forestry. Create a vector of TRUE/FALSE values that indicates if a student has a GPA greater than 3.0 and is a forestry major. Convert the vector of TRUE/FALSE values in part (c) to integer values using the as.numeric() function. Which numeric value corresponds to TRUE? Sum (using the sum() function) the vector you created to count the number of students with GPA &gt; 3.0 and are a forestry major. 2.6 Data Frame data.frame is very much like a simple Excel spreadsheet where each column represents a variable type and each row represent observations. Perhaps the easiest way to create a data frame is to parse vectors in data.frame() function. # create vectors Name = c(&#39;Bob&#39;,&#39;Jeff&#39;,&#39;Mary&#39;) Score = c(90, 75, 92) dt = data.frame(Name, Score) Table ?? show the the data frame created by fusing the two vector together dt %&gt;% kable(&quot;html&quot;,caption = &quot;Variables in the data frame&quot;, align = &quot;c&quot;) %&gt;% column_spec(column = 1:2, width = &quot;4cm&quot;) Table 2.1: Variables in the data frame Name Score Bob 90 Jeff 75 Mary 92 Because the columns have meaning and we have given them column names, it is desirable to want to access an element by the name of the column as opposed to the column number.In large Excel spreadsheets I often get annoyed trying to remember which column something was. The $sign and []are used in R to select variable from the data frame. dt$Name ## [1] Bob Jeff Mary ## Levels: Bob Jeff Mary dt[,1] ## [1] Bob Jeff Mary ## Levels: Bob Jeff Mary dt$Score ## [1] 90 75 92 dt[,2] ## [1] 90 75 92 R has build in dataset that we can use for illustration. For example, Longley (1967) created a longley dataset, which is data frame with 7 economic variables observed every year from 1947 ti 1962 (Table 2.2). We can add the data in the workspace with data() function data(longley) longley %&gt;% kable(caption = &quot;Longleys&#39; Economic dataset&quot;, align = &quot;c&quot;, row.names = F) %&gt;% column_spec(1:7, width = &quot;3cm&quot;) Table 2.2: Longleys’ Economic dataset GNP.deflator GNP Unemployed Armed.Forces Population Year Employed 83.0 234.289 235.6 159.0 107.608 1947 60.323 88.5 259.426 232.5 145.6 108.632 1948 61.122 88.2 258.054 368.2 161.6 109.773 1949 60.171 89.5 284.599 335.1 165.0 110.929 1950 61.187 96.2 328.975 209.9 309.9 112.075 1951 63.221 98.1 346.999 193.2 359.4 113.270 1952 63.639 99.0 365.385 187.0 354.7 115.094 1953 64.989 100.0 363.112 357.8 335.0 116.219 1954 63.761 101.2 397.469 290.4 304.8 117.388 1955 66.019 104.6 419.180 282.2 285.7 118.734 1956 67.857 108.4 442.769 293.6 279.8 120.445 1957 68.169 110.8 444.546 468.1 263.7 121.950 1958 66.513 112.6 482.704 381.3 255.2 123.366 1959 68.655 114.2 502.601 393.1 251.4 125.368 1960 69.564 115.7 518.173 480.6 257.2 127.852 1961 69.331 116.9 554.894 400.7 282.7 130.081 1962 70.551 2.7 Exercise Create a data.frame named my.trees that has the following columns: Girth = c(8.3, 8.6, 8.8, 10.5, 10.7, 10.8, 11.0) Height= c(70, 65, 63, 72, 81, 83, 66) Volume= c(10.3, 10.3, 10.2, 16.4, 18.8, 19.7, 15.6) Extract the third observation (i.e. the third row) Extract the Girth column referring to it by name (don’t use whatever order you placed the columns in). Print out a data frame of all the observations except for the fourth observation. (i.e. Remove the fourth observation/row.) References "],
["importing-data.html", "Chapter 3 Importing data 3.1 Comma-Separated (.csv) 3.2 Microsoft Excel(.xlsx) 3.3 Basic Data Manipulation", " Chapter 3 Importing data 3.1 Comma-Separated (.csv) One of critical steps for data processing is to import data with special format into R workspace.Data import refers to read data from the working directory into the workspace. The most commonly format that R like is the comma-separated files. Base R has functions like read.table(), read.csv(), read.table() and read.csv2() to import data from the local directories into R workspace. We’ll only scratch the surface of data import by read plain-text rectangular files into R. we will use an read_csv() function from readr to import the flight dataset from the working directory into R. The flights dataset contains information of all flights departed from New York City in 2013 (Wickham 2018). The package is under active development under Hadley, Jim and Romain (2017) require(dplyr) require(readr) require(lubridate) require(readxl) require(haven) require(ggplot2) require(kableExtra) flights = read_csv(&quot;flights.csv&quot;) %&gt;% select(-X1) ## Warning: Missing column names filled in: &#39;X1&#39; [1] ## Parsed with column specification: ## cols( ## .default = col_integer(), ## carrier = col_character(), ## tailnum = col_character(), ## origin = col_character(), ## dest = col_character(), ## time_hour = col_datetime(format = &quot;&quot;) ## ) ## See spec(...) for full column specifications. When read_csv() is complete to import the data into R workspace, it prints out a column specification that gives details like the name and type of each column. That’s an important part of readr. 3.2 Microsoft Excel(.xlsx) Commonly our data is stored as a MS Excel file. we can import the file with read_xlsx() function of readxl package. The readxl package provides a function read_exel() that allows us to specify which sheet within the Excel file to read and what character specifies missing data (it assumes a blank cell is missing data if you don’t specifying anything). The function automatically convert the worksheet into a .csv file and read it. audit = readxl::read_xlsx(&quot;audit.xlsx&quot;) The audit file is from the rattle package developed by Maindonald (2012). The dataset which is artificially constructed that has some of the charactersitcis of a true financial audit. I just saved it into the working directory as Excel spreadsheet. I will use this file to illustrate how to import the excel file into R workspace with readxl package (Wickham and Bryan 2018). We look on the internal structure of the audit file with the glimpse() function. You can interact with the table that show all variables and observations (Table ??) audit%&gt;%glimpse() ## Observations: 2,000 ## Variables: 13 ## $ ID &lt;dbl&gt; 1004641, 1010229, 1024587, 1038288, 1044221, 1... ## $ Age &lt;dbl&gt; 38, 35, 32, 45, 60, 74, 43, 35, 25, 22, 48, 60... ## $ Employment &lt;chr&gt; &quot;Private&quot;, &quot;Private&quot;, &quot;Private&quot;, &quot;Private&quot;, &quot;P... ## $ Education &lt;chr&gt; &quot;College&quot;, &quot;Associate&quot;, &quot;HSgrad&quot;, &quot;Bachelor&quot;, ... ## $ Marital &lt;chr&gt; &quot;Unmarried&quot;, &quot;Absent&quot;, &quot;Divorced&quot;, &quot;Married&quot;, ... ## $ Occupation &lt;chr&gt; &quot;Service&quot;, &quot;Transport&quot;, &quot;Clerical&quot;, &quot;Repair&quot;, ... ## $ Income &lt;dbl&gt; 81838.00, 72099.00, 154676.74, 27743.82, 7568.... ## $ Gender &lt;chr&gt; &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Mal... ## $ Deductions &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0... ## $ Hours &lt;dbl&gt; 72, 30, 40, 55, 40, 30, 50, 40, 40, 37, 35, 40... ## $ IGNORE_Accounts &lt;chr&gt; &quot;UnitedStates&quot;, &quot;Jamaica&quot;, &quot;UnitedStates&quot;, &quot;Un... ## $ RISK_Adjustment &lt;dbl&gt; 0, 0, 0, 7298, 15024, 0, 22418, 0, 0, 0, 0, 0,... ## $ TARGET_Adjusted &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0... DT::datatable(audit, rownames = FALSE, caption = &quot;An Interactive table showing the audit data&quot;) Look the frequency audit$Employment%&gt;%table() ## . ## Consultant NA Private PSFederal PSLocal PSState ## 148 100 1411 69 119 72 ## SelfEmp Unemployed Volunteer ## 79 1 1 audit$Gender%&gt;%table()%&gt;%barplot(horiz = TRUE) audit$Marital%&gt;%table()%&gt;%barplot(horiz = TRUE) 3.3 Basic Data Manipulation In this section, we brifely introduce some basic data handling and manipulation techniques, which are mostly associated with data frame. A data frame is a a tabular shaped contains columns and rows of equal length. In general a data frame structure with rows representing observations or measurements and with columns containing variables. 3.3.1 Explore the Data Frame We can visualize the table by simply run the name of the data flights flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, ## # minute &lt;int&gt;, time_hour &lt;dttm&gt; we can use class() to check if the data is data frame flights %&gt;% class() ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; We can use names() to extract the variable names flights %&gt;% names() ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; We can explore the internal structure of flights object with a dplyr()’s function glimpse() flights %&gt;% glimpse() ## Observations: 336,776 ## Variables: 19 ## $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013,... ## $ month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... ## $ day &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... ## $ dep_time &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 55... ## $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 60... ## $ dep_delay &lt;int&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2... ## $ arr_time &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 7... ## $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 7... ## $ arr_delay &lt;int&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -... ## $ carrier &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;DL&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;EV&quot;,... ## $ flight &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79... ## $ tailnum &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N668DN... ## $ origin &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;LGA&quot;, &quot;EWR&quot;, &quot;EWR&quot;... ## $ dest &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ATL&quot;, &quot;ORD&quot;, &quot;FLL&quot;... ## $ air_time &lt;int&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138... ## $ distance &lt;int&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 94... ## $ hour &lt;int&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5,... ## $ minute &lt;int&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ time_hour &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013... We can check how rows (observations/measurements) and columns (variables/fields) are in the data flights %&gt;% dim() ## [1] 336776 19 The number of rows (observation) can be obtained using nrow() function flights %&gt;% nrow() ## [1] 336776 The number of columns (variables) can be obtained using ncol() function flights %&gt;% ncol() ## [1] 19 The length of the data frame is given by flights %&gt;% length() ## [1] 19 3.3.2 simmple summary statistics The most helpful function for for summarizing rows and columns is summary(), which gives a collection of basim cummary statistics. The first method is to calculate some basic summary statistics (minimum, 25th, 50th, 75th percentiles, maximum and mean) of each column. If a column is categorical, the summary function will return the number of observations in each category. flights %&gt;% summary() ## year month day dep_time ## Min. :2013 Min. : 1.000 Min. : 1.00 Min. : 1 ## 1st Qu.:2013 1st Qu.: 4.000 1st Qu.: 8.00 1st Qu.: 907 ## Median :2013 Median : 7.000 Median :16.00 Median :1401 ## Mean :2013 Mean : 6.549 Mean :15.71 Mean :1349 ## 3rd Qu.:2013 3rd Qu.:10.000 3rd Qu.:23.00 3rd Qu.:1744 ## Max. :2013 Max. :12.000 Max. :31.00 Max. :2400 ## NA&#39;s :8255 ## sched_dep_time dep_delay arr_time sched_arr_time ## Min. : 106 Min. : -43.00 Min. : 1 Min. : 1 ## 1st Qu.: 906 1st Qu.: -5.00 1st Qu.:1104 1st Qu.:1124 ## Median :1359 Median : -2.00 Median :1535 Median :1556 ## Mean :1344 Mean : 12.64 Mean :1502 Mean :1536 ## 3rd Qu.:1729 3rd Qu.: 11.00 3rd Qu.:1940 3rd Qu.:1945 ## Max. :2359 Max. :1301.00 Max. :2400 Max. :2359 ## NA&#39;s :8255 NA&#39;s :8713 ## arr_delay carrier flight tailnum ## Min. : -86.000 Length:336776 Min. : 1 Length:336776 ## 1st Qu.: -17.000 Class :character 1st Qu.: 553 Class :character ## Median : -5.000 Mode :character Median :1496 Mode :character ## Mean : 6.895 Mean :1972 ## 3rd Qu.: 14.000 3rd Qu.:3465 ## Max. :1272.000 Max. :8500 ## NA&#39;s :9430 ## origin dest air_time distance ## Length:336776 Length:336776 Min. : 20.0 Min. : 17 ## Class :character Class :character 1st Qu.: 82.0 1st Qu.: 502 ## Mode :character Mode :character Median :129.0 Median : 872 ## Mean :150.7 Mean :1040 ## 3rd Qu.:192.0 3rd Qu.:1389 ## Max. :695.0 Max. :4983 ## NA&#39;s :9430 ## hour minute time_hour ## Min. : 1.00 Min. : 0.00 Min. :2013-01-01 05:00:00 ## 1st Qu.: 9.00 1st Qu.: 8.00 1st Qu.:2013-04-04 13:00:00 ## Median :13.00 Median :29.00 Median :2013-07-03 10:00:00 ## Mean :13.18 Mean :26.23 Mean :2013-07-03 05:02:36 ## 3rd Qu.:17.00 3rd Qu.:44.00 3rd Qu.:2013-10-01 07:00:00 ## Max. :23.00 Max. :59.00 Max. :2013-12-31 23:00:00 ## You noticed that the summary() function provide the common metric for central tendency and measure of dispersion. We will look at them later. Now we turn to our favourite package dplyr References "],
["manipulating-data-with-dplyr.html", "Chapter 4 Manipulating Data with dplyr 4.1 Why use dplyr? 4.2 dplyr functionality 4.3 filter: Keep rows matching criteria 4.4 select: Pick columns by name 4.5 “Chaining” or “Pipelining” 4.6 Pipping with", " Chapter 4 Manipulating Data with dplyr Although many fundamental data processing functions exist in R, they have been a bit convoluted to date and have lacked consistent coding and the ability to easily flow together. This leads to difficult-to-read nested functions and/or choppy code. R Studio is driving a lot of new packages to collate data management tasks and better integrate them with other analysis activities. As a result, a lot of data processing tasks are becoming packaged in more cohesive and consistent ways, which leads to: More efficient code Easier to remember syntax Easier to read syntax The dplyr package provides a set of functions for efficiently manipulating datasets in R writen by Wickham et al. (2018). The package make it easy to transform and summarise tabular data with rows and columns. The dplyr packages contains set of functions—verbs that perfom most common data manipulation tasks like When working with data you must: Figure out what you want to do. Describe those tasks in the form of a computer program. Execute the program. The dplyr package makes these steps fast and easy: By constraining your options, it helps you think about your data manipulation challenges. It provides simple “verbs”, functions that correspond to the most common data manipulation tasks, to help you translate your thoughts into code. It uses efficient backends, so you spend less time waiting for the computer. 4.1 Why use dplyr? Great for data exploration and manipulation Intuitive to write and easy to read, especially when using the chaining syntax Fast on data frame—tabular dataset 4.2 dplyr functionality Five basic verbs: select() to select columns based on their names filter() to rows in data frame arrange() to re-order or arrange the rows in ascending or descending order mutate() to create new columns—add new variable summarise() to make a summary of variable(s) group_by() to group observation sample_n() and rename()to make random sample from the data set The group_by() function perform other common task which are related to the split-apply-combine concept. The dplyr package comes with the pipe operateor %&gt;% from the magrittr package. The pipe operator is very useful for combining several functions in a chain. 4.3 filter: Keep rows matching criteria Base R approach to filtering forces you to repeat the data frame’s name dplyr approach is simpler to write and read Command structure (for all dplyr verbs): first argument is a data frame return value is a data frame nothing is modified in place Note: dplyr generally does not preserve row names require(dplyr) require(readr) require(lubridate) require(readxl) require(haven) require(ggplot2) require(kableExtra) flights = read_csv(&quot;flights.csv&quot;) %&gt;% select(-X1) ## Warning: Missing column names filled in: &#39;X1&#39; [1] ## Parsed with column specification: ## cols( ## .default = col_integer(), ## carrier = col_character(), ## tailnum = col_character(), ## origin = col_character(), ## dest = col_character(), ## time_hour = col_datetime(format = &quot;&quot;) ## ) ## See spec(...) for full column specifications. # base R approach to view all flights on January 1 flights[flights$month==1 &amp; flights$day==1, ] # dplyr approach # note: you can use comma or ampersand to represent AND condition filter(flights, month==1, day==1) ## # A tibble: 842 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 832 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, ## # minute &lt;int&gt;, time_hour &lt;dttm&gt; # use pipe for OR condition 4.4 select: Pick columns by name Base R approach is awkward to type and to read dplyr approach uses similar syntax to filter Like a SELECT in SQL # base R approach to select DepTime, and ArrTime flights[, c(&quot;dep_time&quot;, &quot;arr_time&quot;)] # dplyr approach select(flights, dep_time, arr_time) ## # A tibble: 336,776 x 2 ## dep_time arr_time ## &lt;int&gt; &lt;int&gt; ## 1 517 830 ## 2 533 850 ## 3 542 923 ## 4 544 1004 ## 5 554 812 ## 6 554 740 ## 7 555 913 ## 8 557 709 ## 9 557 838 ## 10 558 753 ## # ... with 336,766 more rows # use colon to select multiple contiguous columns, and use `contains` to match columns by name # note: `starts_with`, `ends_with`, and `matches` (for regular expressions) can also be used to match columns by name select(flights, year:day, contains(&quot;taxi&quot;), contains(&quot;delay&quot;)) ## # A tibble: 336,776 x 5 ## year month day dep_delay arr_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 2 11 ## 2 2013 1 1 4 20 ## 3 2013 1 1 2 33 ## 4 2013 1 1 -1 -18 ## 5 2013 1 1 -6 -25 ## 6 2013 1 1 -4 12 ## 7 2013 1 1 -5 19 ## 8 2013 1 1 -3 -14 ## 9 2013 1 1 -3 -8 ## 10 2013 1 1 -2 8 ## # ... with 336,766 more rows 4.5 “Chaining” or “Pipelining” Bache and Wickham (2014) developed a magrittr package, which has changed the way coding is done in R. It introduce the pipe operator %&gt;% widely known as THEN. Usual way to perform multiple operations in R was through nesting. However, magrittr package introduced a natural order by using the %&gt;% chain multiple operations # nesting method to select UniqueCarrier and DepDelay columns and filter for delays over 60 minutes filter(select(flights, carrier, dep_delay), dep_delay &gt; 60) # chaining method flights %&gt;% select(carrier, dep_delay) %&gt;% filter(dep_delay &gt; 60) ## # A tibble: 26,581 x 2 ## carrier dep_delay ## &lt;chr&gt; &lt;int&gt; ## 1 MQ 101 ## 2 AA 71 ## 3 MQ 853 ## 4 UA 144 ## 5 UA 134 ## 6 EV 96 ## 7 MQ 71 ## 8 B6 77 ## 9 EV 70 ## 10 EV 115 ## # ... with 26,571 more rows Chaining increases readability significantly when there are many commands Operator is automatically imported from the magrittr package Can be used to replace nesting in R commands outside of dplyr. For example, we can create two vectors and calculate Euclidian distance between them using the mathematical equation (4.1) \\[ \\begin{equation} \\theta\\: = \\: \\sqrt {\\sum (x_1 - x_2)^2} \\tag{4.1} \\end{equation} \\] x1 &lt;- 1:5; x2 &lt;- 2:6 sqrt(sum((x1-x2)^2)) # chaining method (x1-x2)^2 %&gt;% sum() %&gt;% sqrt() ## [1] 2.236068 4.6 Pipping with 4.6.1 Choosing columns: select(), rename() Often you work with large datasets with many columns but only a few are actually of interest to you. select() allows you to rapidly zoom in on a useful subset using operations that usually only work on numeric variable positions: # besides just using select() to pick columns... flights %&gt;% select(carrier, flight) ## # A tibble: 336,776 x 2 ## carrier flight ## &lt;chr&gt; &lt;int&gt; ## 1 UA 1545 ## 2 UA 1714 ## 3 AA 1141 ## 4 B6 725 ## 5 DL 461 ## 6 UA 1696 ## 7 B6 507 ## 8 EV 5708 ## 9 B6 79 ## 10 AA 301 ## # ... with 336,766 more rows # ...you can use the minus sign to hide columns flights %&gt;% select(-month, -day) ## # A tibble: 336,776 x 17 ## year dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 517 515 2 830 819 ## 2 2013 533 529 4 850 830 ## 3 2013 542 540 2 923 850 ## 4 2013 544 545 -1 1004 1022 ## 5 2013 554 600 -6 812 837 ## 6 2013 554 558 -4 740 728 ## 7 2013 555 600 -5 913 854 ## 8 2013 557 600 -3 709 723 ## 9 2013 557 600 -3 838 846 ## 10 2013 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;int&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, minute &lt;int&gt;, ## # time_hour &lt;dttm&gt; # hide a range of columns flights %&gt;% select(-(dep_time:arr_delay)) # hide any column with a matching name flights %&gt;% select(-contains(&quot;time&quot;)) ## # A tibble: 336,776 x 13 ## year month day dep_delay arr_delay carrier flight tailnum origin ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 2 11 UA 1545 N14228 EWR ## 2 2013 1 1 4 20 UA 1714 N24211 LGA ## 3 2013 1 1 2 33 AA 1141 N619AA JFK ## 4 2013 1 1 -1 -18 B6 725 N804JB JFK ## 5 2013 1 1 -6 -25 DL 461 N668DN LGA ## 6 2013 1 1 -4 12 UA 1696 N39463 EWR ## 7 2013 1 1 -5 19 B6 507 N516JB EWR ## 8 2013 1 1 -3 -14 EV 5708 N829AS LGA ## 9 2013 1 1 -3 -8 B6 79 N593JB JFK ## 10 2013 1 1 -2 8 AA 301 N3ALAA LGA ## # ... with 336,766 more rows, and 4 more variables: dest &lt;chr&gt;, ## # distance &lt;int&gt;, hour &lt;int&gt;, minute &lt;int&gt; # pick columns using a character vector of column names cols &lt;- c(&quot;carrier&quot;, &quot;flight&quot;, &quot;tailnum&quot;) flights %&gt;% select(one_of(cols)) ## # A tibble: 336,776 x 3 ## carrier flight tailnum ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 UA 1545 N14228 ## 2 UA 1714 N24211 ## 3 AA 1141 N619AA ## 4 B6 725 N804JB ## 5 DL 461 N668DN ## 6 UA 1696 N39463 ## 7 B6 507 N516JB ## 8 EV 5708 N829AS ## 9 B6 79 N593JB ## 10 AA 301 N3ALAA ## # ... with 336,766 more rows # select() can be used to rename columns, though all columns not mentioned are dropped flights %&gt;% select(tail = tailnum) ## # A tibble: 336,776 x 1 ## tail ## &lt;chr&gt; ## 1 N14228 ## 2 N24211 ## 3 N619AA ## 4 N804JB ## 5 N668DN ## 6 N39463 ## 7 N516JB ## 8 N829AS ## 9 N593JB ## 10 N3ALAA ## # ... with 336,766 more rows # rename() does the same thing, except all columns not mentioned are kept flights %&gt;% rename(tail = tailnum) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tail &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, ## # minute &lt;int&gt;, time_hour &lt;dttm&gt; 4.6.2 Choosing rows: filter, between, slice, sample_n, top_n, distinct filter() allows you to select a subset of rows in a data frame. Like all single verbs, the first argument is the tibble (or data frame). The second and subsequent arguments refer to variables within that data frame, selecting rows where the expression is TRUE. For example, we can select all flights on departed between 6:00 and 6:05 in the morning with: flights %&gt;% filter(dep_time &gt;= 600, dep_time &lt;= 605) ## # A tibble: 2,460 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 600 600 0 851 ## 2 2013 1 1 600 600 0 837 ## 3 2013 1 1 601 600 1 844 ## 4 2013 1 1 602 610 -8 812 ## 5 2013 1 1 602 605 -3 821 ## 6 2013 1 2 600 600 0 814 ## 7 2013 1 2 600 605 -5 751 ## 8 2013 1 2 600 600 0 819 ## 9 2013 1 2 600 600 0 846 ## 10 2013 1 2 600 600 0 737 ## # ... with 2,450 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, ## # minute &lt;int&gt;, time_hour &lt;dttm&gt; # between() is a concise alternative for determing if numeric values fall in a range flights %&gt;% filter(between(dep_time, 600, 605)) # side note: is.na() can also be useful when filtering flights %&gt;% filter(!is.na(dep_time)) ## # A tibble: 328,521 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 328,511 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, ## # minute &lt;int&gt;, time_hour &lt;dttm&gt; 4.6.3 Adding new variables: mutate, transmute, add_rownames Besides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. This is the job of mutate(): # mutate() creates a new variable (and keeps all existing variables) flights %&gt;% mutate(speed = distance/air_time*60) ## # A tibble: 336,776 x 20 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 13 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;, hour &lt;int&gt;, ## # minute &lt;int&gt;, time_hour &lt;dttm&gt;, speed &lt;dbl&gt; # transmute() only keeps the new variables flights %&gt;% transmute(speed = distance/air_time*60) ## # A tibble: 336,776 x 1 ## speed ## &lt;dbl&gt; ## 1 370. ## 2 374. ## 3 408. ## 4 517. ## 5 394. ## 6 288. ## 7 404. ## 8 259. ## 9 405. ## 10 319. ## # ... with 336,766 more rows # example data frame with row names mtcars %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # add_rownames() turns row names into an explicit variable mtcars %&gt;% add_rownames(&quot;model&quot;) %&gt;% head() ## Warning: Deprecated, use tibble::rownames_to_column() instead. ## # A tibble: 6 x 12 ## model mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda~ 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsu~ 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Horne~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Horne~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valia~ 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 # side note: dplyr no longer prints row names (ever) for local data frames mtcars %&gt;% tbl_df() ## # A tibble: 32 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # ... with 22 more rows 4.6.4 Grouping and counting: summarise, tally, count, group_size, n_groups, ungroup The verb summarise() collapses a data frame to a single row.It’s not that useful until chained with the group_by() verb below. # summarise() can be used to count the number of rows in each group flights %&gt;% group_by(month) %&gt;% summarise(cnt = n()) ## # A tibble: 12 x 2 ## month cnt ## &lt;int&gt; &lt;int&gt; ## 1 1 27004 ## 2 2 24951 ## 3 3 28834 ## 4 4 28330 ## 5 5 28796 ## 6 6 28243 ## 7 7 29425 ## 8 8 29327 ## 9 9 27574 ## 10 10 28889 ## 11 11 27268 ## 12 12 28135 # tally() and count() can do this more concisely flights %&gt;% group_by(month) %&gt;% tally() # you can sort by the count flights %&gt;% group_by(month) %&gt;% summarise(cnt = n()) %&gt;% arrange(desc(cnt)) ## # A tibble: 12 x 2 ## month cnt ## &lt;int&gt; &lt;int&gt; ## 1 7 29425 ## 2 8 29327 ## 3 10 28889 ## 4 3 28834 ## 5 5 28796 ## 6 4 28330 ## 7 6 28243 ## 8 12 28135 ## 9 9 27574 ## 10 11 27268 ## 11 1 27004 ## 12 2 24951 # you can sum over a specific variable instead of simply counting rows flights %&gt;% group_by(month) %&gt;% summarise(dist = sum(distance)) ## # A tibble: 12 x 2 ## month dist ## &lt;int&gt; &lt;int&gt; ## 1 1 27188805 ## 2 2 24975509 ## 3 3 29179636 ## 4 4 29427294 ## 5 5 29974128 ## 6 6 29856388 ## 7 7 31149199 ## 8 8 31149334 ## 9 9 28711426 ## 10 10 30012086 ## 11 11 28639718 ## 12 12 29954084 # tally() and count() have a wt parameter for this purpose flights %&gt;% group_by(month) %&gt;% tally(wt = distance) flights %&gt;% count(month, wt = distance) # group_size() returns the counts as a vector flights %&gt;% group_by(month) %&gt;% group_size() ## [1] 27004 24951 28834 28330 28796 28243 29425 29327 27574 28889 27268 ## [12] 28135 # n_groups() simply reports the number of groups flights %&gt;% group_by(month) %&gt;% n_groups() ## [1] 12 # group by two variables, summarise, arrange (output is possibly confusing) flights %&gt;% group_by(month, day) %&gt;% summarise(cnt = n()) %&gt;% arrange(desc(cnt)) %&gt;% print(n = 40) # A tibble: 365 x 3 # Groups: month [12] month day cnt &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 11 27 1014 2 7 11 1006 3 7 8 1004 4 7 10 1004 5 12 2 1004 6 7 18 1003 7 7 25 1003 8 7 12 1002 9 7 9 1001 10 7 17 1001 11 7 31 1001 12 8 7 1001 13 8 8 1001 14 8 12 1001 15 7 22 1000 16 7 24 1000 17 8 1 1000 18 8 5 1000 19 8 15 1000 20 11 21 1000 21 7 15 999 22 7 19 999 23 7 26 999 24 7 29 999 25 8 2 999 26 8 9 999 27 11 22 999 28 8 16 998 29 7 23 997 30 7 30 997 31 8 14 997 32 7 16 996 33 8 6 996 34 8 19 996 35 9 13 996 36 9 26 996 37 9 27 996 38 4 15 995 39 6 20 995 40 6 26 995 # ... with 325 more rows # ungroup() before arranging to arrange across all groups flights %&gt;% group_by(month, day) %&gt;% summarise(cnt = n()) %&gt;% ungroup() %&gt;% arrange(desc(cnt)) # A tibble: 365 x 3 month day cnt &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 11 27 1014 2 7 11 1006 3 7 8 1004 4 7 10 1004 5 12 2 1004 6 7 18 1003 7 7 25 1003 8 7 12 1002 9 7 9 1001 10 7 17 1001 # ... with 355 more rows References "],
["reshaping-data-with-tidyr.html", "Chapter 5 Reshaping data with tidyr 5.1 gather( ) function: 5.2 separate( ) function:", " Chapter 5 Reshaping data with tidyr Most of the time, our data is in the form of a data frame and we are interested in exploring the relationships. However most procedures in R expect the data to show up in a ‘long’ format where each row is an observation and each column is a variable. In practice, the data is often not stored like that and the data comes to us with repeated observations included on a single row. This is often done as a memory saving technique or because there is some structure in the data that makes the ‘wide’ format attractive. As a result, we need a way to convert data from ‘wide’ to ‘long’ and vice-versa. tidyr is a one such package which was built for the sole purpose of simplifying the process of creating tidy data (Wickham and Henry 2018). This tutorial provides you with the basic understanding of the four fundamental functions of data tidying that tidyr provides: gather() makes “wide” data longer spread() makes “long” data wider separate() splits a single column into multiple columns unite() combines multiple columns into a single column require(dplyr) require(readr) require(lubridate) require(readxl) require(haven) require(ggplot2) require(kableExtra) require(tidyr) 5.1 gather( ) function: There are times when our data is considered unstacked and a common attribute of concern is spread out across columns. To reformat the data such that these common attributes are gathered together as a single variable, the gather() function will take multiple columns and collapse them into key-value pairs, duplicating all other columns as needed. in short gather() function reshape wide format to long format (Figure 5.1) Figure 5.1: Reshaped data set from wide to long format The data in table 5.1 data is considered wide since the time variable (represented as quarters) is structured such that each quarter represents a variable. To re-structure the time component as an individual variable, we can gather each quarter within one column variable and also gather the values associated with each quarter in a second column variable. wide = read_table2(&quot;wide_data.txt&quot;) ## Parsed with column specification: ## cols( ## Group = col_integer(), ## Year = col_integer(), ## Qtr.1 = col_integer(), ## Qtr.2 = col_integer(), ## Qtr.3 = col_integer(), ## Qtr.4 = col_integer() ## ) wide %&gt;% kable(&quot;html&quot;, caption = &quot;Revenue data in Wide form&quot;)%&gt;% column_spec(column = 1:6, width = &quot;3cm&quot;, color = 1) %&gt;% add_header_above(c(&quot;&quot; , &quot;&quot;, &quot;Income per Quarter&quot; = 4), line = T) Table 5.1: Revenue data in Wide form Income per Quarter Group Year Qtr.1 Qtr.2 Qtr.3 Qtr.4 1 2006 15 16 19 17 1 2007 12 13 27 23 1 2008 22 22 24 20 1 2009 10 14 20 16 2 2006 12 13 25 18 2 2007 16 14 21 19 2 2008 13 11 29 15 2 2009 23 20 26 20 3 2006 11 12 22 16 3 2007 13 11 27 21 3 2008 17 12 23 19 3 2009 14 9 31 24 We use the gather() function to convert data in table 5.1 to long form widely known as indexed data shown in table 5.2 long = wide %&gt;% gather(key = &quot;key&quot;, value = &quot;Revenue&quot;, 3:6) Table 5.2: Revenue data in long form Group Year key Revenue 1 2006 Qtr.1 15 1 2007 Qtr.1 12 1 2008 Qtr.1 22 1 2009 Qtr.1 10 2 2006 Qtr.1 12 2 2007 Qtr.1 16 2 2008 Qtr.1 13 2 2009 Qtr.1 23 3 2006 Qtr.1 11 3 2007 Qtr.1 13 3 2008 Qtr.1 17 3 2009 Qtr.1 14 1 2006 Qtr.2 16 1 2007 Qtr.2 13 1 2008 Qtr.2 22 1 2009 Qtr.2 14 2 2006 Qtr.2 13 2 2007 Qtr.2 14 2 2008 Qtr.2 11 2 2009 Qtr.2 20 3 2006 Qtr.2 12 3 2007 Qtr.2 11 3 2008 Qtr.2 12 3 2009 Qtr.2 9 1 2006 Qtr.3 19 1 2007 Qtr.3 27 1 2008 Qtr.3 24 1 2009 Qtr.3 20 2 2006 Qtr.3 25 2 2007 Qtr.3 21 2 2008 Qtr.3 29 2 2009 Qtr.3 26 3 2006 Qtr.3 22 3 2007 Qtr.3 27 3 2008 Qtr.3 23 3 2009 Qtr.3 31 1 2006 Qtr.4 17 1 2007 Qtr.4 23 1 2008 Qtr.4 20 1 2009 Qtr.4 16 2 2006 Qtr.4 18 2 2007 Qtr.4 19 2 2008 Qtr.4 15 2 2009 Qtr.4 20 3 2006 Qtr.4 16 3 2007 Qtr.4 21 3 2008 Qtr.4 19 3 2009 Qtr.4 24 The spread() function is a complement functiongather()` as it convert long format dataset into wide form wide.wide = long %&gt;% spread(key = &quot;key&quot;, value = &quot;Revenue&quot;) 5.2 separate( ) function: Many times a single column variable will capture multiple variables, or even parts of a variable you just don’t care about. Examples include is data in table 5.3). usa = read_csv(&quot;separate.csv&quot;) ## Parsed with column specification: ## cols( ## Grp_Ind = col_character(), ## Yr_Mo = col_character(), ## City_State = col_character(), ## First_Last = col_character(), ## Extra_variable = col_character() ## ) Table 5.3: Messy data with variable combined Grp_Ind Yr_Mo City_State First_Last Extra_variable 1.a 2006_Jan Dayton (OH) George Washington XX01person_1 1.b 2006_Feb Grand Forks (ND) John Adams XX02person_2 1.c 2006_Mar Fargo (ND) Thomas Jefferson XX03person_3 2.a 2007_Jan Rochester (MN) James Madison XX04person_4 2.b 2007_Feb Dubuque (IA) James Monroe XX05person_5 2.c 2007_Mar Ft. Collins (CO) John Adams XX06person_6 3.a 2008_Jan Lake City (MN) Andrew Jackson XX07person_7 3.b 2008_Feb Rushford (MN) Martin Van Buren XX08person_8 3.c 2008_Mar Unknown William Harrison XX09person_9 In each of these cases, our objective may be to separate characters within the variable string. This can be accomplished using the separate() function which splits a single variable into multiple variables. Table 5.4 show the tidy data after the variables were separated. The complement function to separate() is the unite(), which merge two variables into one. usa.sep = usa %&gt;% separate(Grp_Ind, c(&quot;Group&quot;, &quot;Individual&quot;), remove = TRUE, convert = TRUE) %&gt;% separate(Yr_Mo, c(&quot;Year&quot;, &quot;Month&quot;), remove = TRUE, convert = TRUE) %&gt;% separate(City_State, c(&quot;City&quot;, &quot;State&quot;), remove = TRUE, convert = TRUE) %&gt;% separate(First_Last, c(&quot;First&quot;, &quot;Last&quot;), remove = TRUE, convert = TRUE) %&gt;% separate(Extra_variable, c(&quot;Extra&quot;, &quot;Variable&quot;), remove = TRUE, convert = TRUE) ## Warning: Expected 2 pieces. Additional pieces discarded in 8 rows [1, 2, 3, ## 4, 5, 6, 7, 8]. ## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [9]. ## Warning: Expected 2 pieces. Additional pieces discarded in 1 rows [8]. Table 5.4: Tidy data with variable separated Group Individual Year Month City State First Last Extra Variable 1 a 2006 Jan Dayton OH George Washington XX01person 1 1 b 2006 Feb Grand Forks John Adams XX02person 2 1 c 2006 Mar Fargo ND Thomas Jefferson XX03person 3 2 a 2007 Jan Rochester MN James Madison XX04person 4 2 b 2007 Feb Dubuque IA James Monroe XX05person 5 2 c 2007 Mar Ft Collins John Adams XX06person 6 3 a 2008 Jan Lake City Andrew Jackson XX07person 7 3 b 2008 Feb Rushford MN Martin Van XX08person 8 3 c 2008 Mar Unknown NA William Harrison XX09person 9 References "],
["visualisation-with-ggplot2.html", "Chapter 6 Visualisation with ggplot2 6.1 Univariate Distributions 6.2 Continuous Variables 6.3 Graphics with ggplot", " Chapter 6 Visualisation with ggplot2 There are three major “systems” of making graphs in R. The basic plotting commands in R are quite effective but the commands do not have a way of being combined in easy ways. Lattice graphics (which the mosaic package uses) makes it possible to create some quite complicated graphs but it is very difficult to do make non-standard graphs. The last package, ggplot2 tries to not anticipate what the user wants to do, but rather provide the mechanisms for pulling together different graphical concepts and the user gets to decide which elements to combine. The ggplot2 package, created by Hadley Wickham (2016), offers a powerful graphics language for creating elegant and complex plots. Its popularity in the R community has exploded in recent years. Originally based on Leland Wilkinson’s The Grammar of Graphics (2006), ggplot2 allows you to create graphs that represent both univariate and multivariate numerical and categorical data in a straightforward manner. 6.1 Univariate Distributions Before moving on to more sophisticated visualizations that enable multidimensional investigation, it is important to be able to understand how an individual variable is distributed. Visually understanding the distribution allows us to describe many features of a variable. 6.2 Continuous Variables A variable is continuous if it can take any of an infinite set of ordered values. There are several different plots that can effectively communicate the different features of continuous variables. Features we are generally interested in include: Measures of location Measures of spread Asymmetry Outliers Gaps Hadley Wickham in his book Elegant Graphics for Data Analysis with ggplot clearly said ggplot2 is designed to act on data frames (Wickham 2016). It is actually hard to just draw three data points and for simple graphs it might be easier to use the base graphing system in R. Fortunate ggplot2 makes plotting easy because of its large number of basic building blocks that, when stacked upon each other, can produce extremely complicated graphs. A full list is available at http://docs.ggplot2.org/current/. In summary, we can break the art of making graph with ggplot2 three main steps. Understand the type of data you are going to use Ask yourself what is the major relationship we wish to examine? Choose the appropriate graph that suits your data. We will use the audit dataset in table 6.1 to illustrate how to use ggplot2 package to make elegant graphics in R. We chopped this dataset from the rattle package. The audit dataset is an artificially constructed dataset that has some of the characteristics of a true financial audit datase (Maindonald 2012) Table 6.1: Individual Auditing Infomration ID Age Employment Education Marital Occupation Income Gender 5510960 49 SelfEmp Vocational Divorced Executive 100800.81 Male 9127765 61 Private Yr7t8 Widowed Service 78161.84 Female 8116036 18 NA HSgrad Absent NA 200908.22 Female 4930197 48 Consultant College Married Transport 16557.72 Male 4094530 44 Consultant Master Absent Farming 189456.13 Male 4096413 18 Private Yr7t8 Absent Sales 127464.30 Male 5808981 53 Private College Married Clerical 31969.17 Male 5875221 20 Private College Absent Clerical 176057.51 Female 3834978 32 Private College Married Transport 16792.08 Male 7082414 34 Private Bachelor Married Professional 46006.17 Male 6.3 Graphics with ggplot 6.3.1 Categorical Data 6.3.1.1 Barplot The ggplot() function only needs to specify the data and aes. Note the unusual use of the plus sign “+” to add the effect of of geom_bar() to ggplot(). Only one variable plays an aesthetic role: workshop. The aes() function sets that role. To produce figure 6.1 you can write the code below: ggplot(data = audit, aes(x = Education))+ geom_bar() Figure 6.1: Barplot of frequency of people with various education level Figure 6.1 plot some of the education that are of no interest to us, we can limit the education level by adding a limits function in the scale_x_discrete() function to produce figure 6.2. The code for figure 6.2 is: ggplot(data = audit, aes(x = Education))+ geom_bar() + scale_x_discrete(limits = c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)) Figure 6.2: Barplot of frequency of people in six education level If you want to fill the bars with color (Figure 6.3), you can parsethe fill argument in geom_bar(). ggplot(data = audit, aes(x = Education))+ geom_bar(fill = c(&quot;red&quot;, &quot;purple&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;maroon&quot;, &quot;pink&quot;)) + scale_x_discrete(limits = c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)) Figure 6.3: Barplot of frequency of people in six education level The use of color in figure 6.3 was, well, colorful, but it did not add any useful information. However, when displaying bar plots of six education level, the fill argument with Gender very useful. Figure 6.4 I use fill to color the bars by gender and set the “position” to stack. ggplot(data = audit, aes(x = Education))+ geom_bar(aes(fill = Gender), position = &quot;stack&quot;) + scale_x_discrete(limits = c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)) Figure 6.4: Barplot of frequency of people in six education level Figure 6.5 is similar to figure 6.4, changing only the bar position to be dodge. ggplot(data = audit, aes(x = Education))+ geom_bar(aes(fill = Gender), position = &quot;dodge&quot;) + scale_x_discrete(limits = c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)) Figure 6.5: Barplot of frequency of people in six education level 6.3.1.2 Pre-summarized Data The geom_bar() function summarizes data for you. If it is already summarized, you use geom_col() instead. The chunk below summarize the eduction level and then plot the summarized result in figure 6.6. education = audit %&gt;% filter(Education %in% c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)) %&gt;% group_by(Education) %&gt;% summarise(Count = n()) ggplot(data = education, aes(x = Education, y = Count))+geom_col()+ scale_x_discrete(limits = c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)) Figure 6.6: Barplot of frequency of people in six education level 6.3.2 Numerical Data 6.3.2.1 Histograms Histograms are often overlooked, yet they are a very efficient means for communicating distribution of continuous variables. geom_histogram() is used to make histogram in ggplot2 package. Figure 6.7 was created using the code in the chunk below: ggplot(data = audit, aes(x = Age)) + geom_histogram() Figure 6.7: Age distribution labs() function is used in ggplot2 to add annotations in plot as in figure 6.8. ggplot(data = audit%&gt;% filter(Education %in% c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)), aes(x = Age)) + geom_histogram()+ labs(x = &quot;Age of Individuals&quot;, y = &quot;Number of Individuals&quot;, title = &quot;The Age of Individuals audited in US&quot;, subtitle = &quot;The audit was done to 2000 individuals aiming to illustrate the auditing&quot;) Figure 6.8: Age distribution facet_wrap() function is used in ggplot2 to make multiple plots in a single layout as illustrated n figure 6.9. ggplot(data = audit%&gt;% filter(Education %in% c(&quot;Preschool&quot;, &quot;Vocational&quot;, &quot;College&quot;,&quot;Bachelor&quot;, &quot;Master&quot;, &quot;Doctorate&quot;)), aes(x = Age)) + geom_histogram()+ labs(x = &quot;Age of Individuals&quot;, y = &quot;Number of Individuals&quot;) + facet_wrap(~Education, scales = &quot;free_y&quot;) Figure 6.9: Age distribution grouped by education level References "],
["adding-equations-to-your-document.html", "Chapter 7 Adding Equations to Your Document 7.1 Subscripts and Superscripts 7.2 Square Roots 7.3 Fractions 7.4 Summation Expressions 7.5 Greek Letters 7.6 Special Symbols 7.7 Special Functions 7.8 Mathematical equations. 7.9 The binomial probability: 7.10 Aligning Equations with Comments", " Chapter 7 Adding Equations to Your Document 7.1 Subscripts and Superscripts To indicate a subscript, use the underscore _ character. To indicate a superscript, use a single caret character ^. Note: this can be confusing, because the R Markdown language delimits superscripts with two carets. In LaTeX equations, a single caret indicates the superscript. If the subscript or superscript has just one character, there is no need to delimit with braces. However, if there is more than one character, braces must be used. The following examples illustrate: $X_i$ display as \\(X_i\\) and this LaTeX form$X_{i}$ display as \\(X_{i}\\) Notice that in the above case, braces were not actually needed. In this next example, however, failure to use braces creates an error, as LaTeX sets only the first character as a subscript $X_{i,j}$ display as \\(X_{i,j}\\) and $X_i,j$ diaplay as \\(X_i,j\\) This expression $X^2_{i,j}$ which display as \\(X^2_{i,j}\\) that uses both subscripts and superscripts 7.2 Square Roots This expression $\\sqrt{b^2 - 4ac}$ display \\(\\sqrt{b^2 - 4ac}\\) . We indicate a square root using the \\sqrt operator. 7.3 Fractions Displayed fractions are typeset using the \\frac operator. for instance, this expression $\\frac{4z^3}{16}$ display as \\(\\frac{4z^3}{16}\\) 7.4 Summation Expressions These are indicated with the \\(\\sum\\) operator, followed by a subscript for the material appearing below the summation sign, and a superscript for any material appearing above the summation sign. Example, this expression $\\sum_{i=1}^{n} X^3_i$ display as \\(\\sum_{i=1}^{n} X^3_i\\) 7.5 Greek Letters Many statistical expressions use Greek letters. Much of the Greek alphabet is implemented in LaTeX, as indicated in the LaTeX cheat sheet available at the course website. There are both upper and lower case versions available for some letters. for instance, $\\alpha, \\beta, \\gamma, \\Gamma$ displays as \\(\\alpha, \\beta, \\gamma, \\Gamma\\) 7.6 Special Symbols All common mathematical symbols are implemented, and you can find a listing on the LaTeX cheat sheet.Some examples. (Notice that, in the third example, I use the tilde character for a forced space. Generally LaTeX does spacing for you automatically, and unless you use the tilde character, R will ignore your attempts to add spaces.). This expression $a \\pm b$ display as \\(a \\pm b\\), $x \\ge 15$ displays as \\(x \\ge 15\\); $a_i \\ge 0~~~\\forall i$show as \\(a_i \\ge 0~~~\\forall i\\); and $x \\le 15$ show as \\(x \\le 15\\). 7.7 Special Functions LaTeX typesets special functions in a different font from mathematical variables. These functions, such as sin, cos , etc. are indicated in LaTeX with a backslash. This expression $\\int_0^{2\\pi} \\sin x~dx$ which appear as \\(\\int_0^{2\\pi} \\sin x~dx\\) illustrates how to typeset an integral. 7.8 Mathematical equations. compute the variance , average and standard deviation of a set of vector. The average of a vector is \\(\\bar{x} = \\sum \\frac{x_i}{n}\\), where \\(\\sum x_i = x_1 + _\\cdots + x_n\\) is the sum of the input values. The standard deviation expressed below appear as mathematical equation (7.1) $$ \\begin{equation} s = \\sqrt{\\frac{\\sum(x_i - \\bar{x})^2}{n-1}} (\\#eq:eqn2) \\end{equation} $$ Appear as \\[ \\begin{equation} s = \\sqrt{\\frac{\\sum(x_i - \\bar{x})^2}{n-1}}\\tag{7.1} \\end{equation} \\] However, equation (7.1) is not suitable for the task. Because by the time \\(\\bar{x}\\) is computed, the individual \\(x_i\\) are gone. Alternatively is to use the equation (7.2), which compute the quantity by keeping track of the count, sum, and sum of the squares as the input values are processed. $$ \\begin{equation} s = \\sqrt\\frac{\\sum x_{i}^2 - \\frac{1}{n}(\\sum x_i)^2}{n - 1}(\\#eq:eqn3) \\end{equation} $$ \\[ \\begin{equation} s = \\sqrt\\frac{\\sum x_{i}^2 - \\frac{1}{n}(\\sum x_i)^2}{n - 1}\\tag{7.2} \\end{equation} \\] 7.9 The binomial probability: The binomial probability in equation (7.3) is mathematically expressed as$$ \\begin{equation} f(y|N,p) = \\frac{N!}{y!(N-y)!}\\cdot p^y \\cdot (1-p)^{N-y} = {{N}\\choose{y}} \\cdot p^y \\cdot (1-p)^{N-y} (\\#eq:eqn4) \\end{equation} $$ \\[ \\begin{equation} f(y|N,p) = \\frac{N!}{y!(N-y)!}\\cdot p^y \\cdot (1-p)^{N-y} = {{N}\\choose{y}} \\cdot p^y \\cdot (1-p)^{N-y} \\tag{7.3} \\end{equation} \\] The expression $$\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n}x_{i}$$ calculate the mean of observations of variable , as shown in equation (7.4): \\[ \\begin{equation} \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n}x_{i} \\tag{7.4} \\end{equation} \\] The equation for computing variance (equation (7.5)) is expressed mathematically as $\\sigma^{2} = \\frac{\\sum\\limits_{i=1}^{n} \\left(x_{i} - \\bar{x}\\right)^{2}} {n-1}$ \\[ \\begin{equation} \\sigma^{2} = \\frac{\\sum_{i=1}^{n} \\left(x_{i} - \\bar{x}\\right)^{2}} {n-1} \\tag{7.5} \\end{equation} \\] Next, the equation for computing covariance (equation (7.7)) is expressed mathematically as $\\begin{equation}cov_{x,y} = \\frac{\\sum\\limits_{i=1}^{n}{(x_i-\\overline{x}) \\cdot (y_i-\\overline{y})} }{n-1} \\tag{7.6}\\end{equation}$ \\[ \\begin{equation} cov_{x,y} = \\frac{\\sum\\limits_{i=1}^{n}{(x_i-\\overline{x}) \\cdot (y_i-\\overline{y})} }{n-1} \\tag{7.7} \\end{equation} \\] And, then, the equation for computing standard deviation (equation (7.8)) is expressed mathematically as $\\sigma = \\sqrt{\\frac{\\sum\\limits_{i=1}^{n} \\left(x_{i} - \\bar{x}\\right)^{2}} {n-1}} (\\#eq:eqn8)$ \\[ \\begin{equation} \\sigma = \\sqrt{\\frac{\\sum\\limits_{i=1}^{n} \\left(x_{i} - \\bar{x}\\right)^{2}} {n-1}} \\tag{7.8} \\end{equation} \\] There are helpful online editors to help you learn code for various equations you might want to include. I have found the one at: http://visualmatheditor.equatheque.net/VisualMathEditor.html to be very useful. You can work out the code there and then copy it over to your RMarkdown document in between dollar signs (1 or 2 on either end depending on whether you want the equation in line or in display mode). Right Left Default Center 12 12 12 12 123 123 123 123 1 1 1 1 7.10 Aligning Equations with Comments In proving a result, it is often useful to include comments. Here is an expression showing how you can do that. $$ \\begin{align} 3+x &amp;=4 &amp;&amp; \\text{(Solve for} x \\text{.)}\\\\ x &amp;=4-3 &amp;&amp; \\text{(Subtract 3 from both sides.)}\\\\ x &amp;=1 &amp;&amp; \\text{(Yielding the solution.)} \\end{align} $$ ` Result into \\[ \\begin{align} 3+x &amp;=4 &amp;&amp; \\text{(Solve for} x \\text{.)}\\\\ x &amp;=4-3 &amp;&amp; \\text{(Subtract 3 from both sides.)}\\\\ x &amp;=1 &amp;&amp; \\text{(Yielding the solution.)} \\end{align} \\] In Acts 20:35 Paul quoted Jesus when he said: it is better to give than to receive! "],
["references.html", "References", " References "]
]
